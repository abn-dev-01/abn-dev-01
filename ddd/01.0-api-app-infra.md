
- [Layers](./api-app-infra.md#layers)
  - [Api Layer](./api-app-infra.md#api-layer)
  - [Application Layer](./api-app-infra.md#application-layer)
  - [Infrastructure Layer](./api-app-infra.md#infrastructure-layer)
- [DTO vs Model](./api-app-infra.md#dto-vs-model-)
- [Application should have any mappers ?](./api-app-infra.md#application-should-have-any-mappers-)
- [Highâ€‘Level Relationship](./api-app-infra.md#-highlevel-relationship)
- [File Storage Agnostic](./01.01-file-storage.md)

---

# Layers

Our service is organized into three clear layers:

- **api**
- **application**
- **infrastructure**

Each layer has a strict responsibility and dependency direction.

---

# API Layer  
This layer is simply called **`api`**.

It contains everything related to **incoming communication** with the service.  
Its job is to **receive external requests**, translate them into core models, and call the application layer.

### Responsibilities
- REST controllers  
- Thin service classes used only by controllers  
- Request/response DTOs  
- Mappers between API DTOs and core DTOs  
- Inbound message listeners (SQS, Kafka, etc.) if applicable  

### Key rule
**No business logic here.**  
This layer is only an adapter between the outside world and the core.

---

# Application Layer  
This layer is the **core** of the system.

It contains **business logic**, **use cases**, and **technologyâ€‘agnostic abstractions**.  
It must not depend on frameworks, AWS, Spring annotations, or any external technology.

### Why this matters
If Customer decides to replace SQS with Kafka, or Kafka with Azure Queue, **only the infrastructure layer changes**.  
The application layer remains untouched and not binded with the infrastructure layer.

### Responsibilities
- Business logic classes  
- Use case services  
- Ports (interfaces) that describe what the core *needs*, not how itâ€™s implemented  
  - e.g., `FileStorage`, `EventPublisher`, `UserRepository`  
- Core DTOs and core models  
- Mappers between core DTOs and domain models  
- Application-level configuration objects (pure, frameworkâ€‘free)

### Key rule
**Names must be businessâ€‘oriented, not technologyâ€‘oriented.**  
No `SqsPublisher`, `KafkaClient`, etc.  
Instead: `OrderEventPublisher`, `DocumentStorage`, `NotificationSender`.

---

# Infrastructure Layer  
This layer is called **`infrastructure`** or simply **`infra`**.

It contains all **technical implementations** of the ports defined in the application layer.  
Anything that touches external systems lives here.

### Responsibilities
- Implementations of `application ports` 
  - SQS clients  
  - Kafka producers  
  - HTTP clients  
  - S3 storage clients  
- Database access  
  - Entities  
  - Repositories  
  - Persistence mappers  
- Outbound message producers  
- Framework-specific configuration (Spring, AWS SDK, Kafka clients, etc.)

### Key rule
**Infrastructure depends on application, never the other way around.**

---

# Final Summary

| Layer | Purpose | Contains | Must Not Contain |
|-------|---------|----------|------------------|
| **api** | Entry points | Controllers, listeners, API DTOs, API mappers | Business logic |
| **application** | Core business logic | Use cases, ports, core DTOs/models | Frameworks, AWS, DB, SQS/Kafka |
| **infrastructure** | Technical implementations | Entities, repositories, SQS/Kafka/S3 clients | Business rules |


---

# 

```
api/
  controller/         â† REST entry points
  dto/                â† Request/response DTOs
  mapper/             â† API DTO â†” Core DTO
  listener/           â† SQS/Kafka listeners (inbound)

application/
  service/            â† Use cases
  dto/                â† Core DTOs
  model/              â† Core models
  port/               â† Interfaces for outbound messaging (SQS/Kafka/etc.)

infrastructure/
  persistence/
    entity/           â† JPA entities
    mapper/           â† Entity â†” Core DTO
    repository/       â† JPA repositories
  client/
    sqs/              â† SQS clients (senders)
    kafka/            â† Kafka clients (producers)
    http/             â† External REST clients
  config/             â† Spring configs, beans

  ```


---

# Dto vs Model ?

Hereâ€™s the clean, practical distinction youâ€™re looking for â€” the one that actually matters in real architectures like yours.

---

#  **DTO vs Model â€” the real difference**

## **1. DTO (Data Transfer Object)**  
A DTO exists **only to transfer data across layers or boundaries**.

### Purpose:
- Carry data **in/out** of your service  
- Serialize/deserialize (JSON, SQS message, CSV row, etc.)  
- Shape data for a specific consumer (API, queue, batch job)

### Characteristics:
- No business logic  
- Often flat  
- Often different per adapter (API DTO, SQS DTO, DB DTO)  
- Optimized for transport, not meaning  

### Examples:
- `UserRequestDto` (API input)  
- `UserResponseDto` (API output)  
- `UserMessageDto` (SQS message)  
- `UserEntityDto` (if mapping from DB entity to core model)

DTOs are **bound to the boundary** where they are used.

---

## **2. Model (Core Model / Domain Model)**  
A Model represents **business meaning**, not transport format.

### Purpose:
- Represent concepts inside your application  
- Used by services, use cases, domain logic  
- Stable, longâ€‘living structure  
- Independent of API, DB, AWS, frameworks

### Characteristics:
- Can contain business rules  
- Can be rich (value objects, aggregates)  
- Used across the application layer  
- Does not depend on JSON, JPA, SQS, etc.

### Examples:
- `User` (core model)  
- `Order`  
- `Payment`  
- `CustomerProfile`  

Models are **how your application thinks**.

---

#  **The simplest way to remember**

| Aspect | DTO | Model |
|-------|-----|--------|
| Purpose | Move data across boundaries | Represent business concepts |
| Lives in | `api` or `infrastructure` | `application` (or domain) |
| Depends on | JSON, SQS, REST, DB | Nothing external |
| Shape | Optimized for transport | Optimized for business logic |
| Logic | None | Can contain rules |

---

#  **In your architecture**

### **API DTO**  
`api/dto/*`  
Used by controllers and listeners.

### **Core Model / Core DTO**  
`application/model/*` or `application/dto/*`  
Used by core services and use cases.

### **Entity (DB model)**  
`infrastructure/persistence/entity/*`  
Used by JPA/Hibernate.

---

#  Why this distinction matters  
Because mixing DTOs and Models leads to:

- Leaky abstractions  
- API changes breaking business logic  
- DB schema changes leaking into core logic  
- Impossible-to-test application layer  
- Tight coupling to frameworks  

Keeping them separate gives you:

- Clean boundaries  
- Stable core  
- Easy refactoring  
- Replaceable adapters (REST â†’ SQS â†’ Kafka)  
- Predictable mapping rules  

---


# Application should have any mappers ?

Short answer: **yes, but only very specific ones** â€” and definitely *not* the mappers that touch API DTOs or Entities.

---

# Application layer *can* have mappers â€” but only **core mappers**

### What belongs in application:
Mappers that convert **between core models inside the application layer**.

Examples:
- `OrderModel` â†” `OrderDto`
- `UserModel` â†” `UserSummary`
- `ValueObject` â†” `CoreDto`

These are **pure**, frameworkâ€‘free transformations that help the core express business logic cleanly.

### Why they belong here:
- They donâ€™t depend on API DTOs  
- They donâ€™t depend on Entities  
- They donâ€™t depend on frameworks  
- They are part of the business logicâ€™s internal structure  

These mappers help keep the core expressive and decoupled.

---

# What does *not* belong in application:
### 1. **API DTO â†” Core DTO mappers**
These belong in `api/mapper`.

Reason:  
API DTOs are transportâ€‘specific. The application layer must not know about them.

### 2. **Entity â†” Core DTO mappers**
These belong in `infrastructure/persistence/mapper`.

Reason:  
Entities are persistenceâ€‘specific. The application layer must not know about them.

---

# Clean rule of thumb

| Mapper type | Layer |
|-------------|--------|
| API DTO â†” Core DTO | api |
| Entity â†” Core DTO | infrastructure |
| Core Model â†” Core DTO | application |

If the mapper touches **anything external** (API, DB, AWS, messaging), it does *not* belong in application.

If the mapper is **pure business transformation**, it belongs in application.

---

Let me give you the **clearest, most correct explanation** of the relationships between **api â†’ application â†’ infrastructure** in *your* architecture, using your naming rules and your mental model.

Iâ€™ll keep it sharp, structured, and aligned with clean architecture principles.

---

# ğŸŸ¦ Highâ€‘Level Relationship

Think of the three layers like this:

| Layer | Depends On | Purpose |
|------|------------|---------|
| **api** | â†’ application | Expose REST endpoints, map HTTP â†” domain |
| **application** | â†’ nothing (only domain + ports) | Business logic, use cases, ports (interfaces) |
| **infrastructure** | â†’ application | Implement ports using real technologies (S3, DB, SQS) |

**Dependency direction always points inward â†’ toward application.**

---

# ğŸŸ© How They Interact (Flow)

### **1. API layer receives a request**
- Controller gets HTTP request
- Converts request data into simple types or DTOs
- Calls a service in the application layer

### **2. Application layer executes business logic**
- Contains use cases (e.g., `TemplateService`)
- Calls outbound ports (interfaces starting with `I`)
- Has no idea what S3, AWS, HTTP, or Spring is

### **3. Infrastructure layer fulfills the port**
- Implements the port (e.g., `S3TemplateStorage implements ITemplateStorage`)
- Talks to AWS S3, DB, filesystem, etc.
- Returns domain objects back to application

### **4. Application returns result to API**
- API maps domain â†’ response DTO
- Sends HTTP response

---

# ğŸŸ§ Visual Diagram (Your Architecture)

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚            api               â”‚
          â”‚  - Controllers               â”‚
          â”‚  - Request/Response DTOs     â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ calls
                          â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚         application           â”‚
          â”‚  - Services (use cases)       â”‚
          â”‚  - Ports (I*)                 â”‚
          â”‚  - Domain models              â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ implemented by
                          â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚        infrastructure         â”‚
          â”‚  - S3TemplateStorage          â”‚
          â”‚  - DB repositories            â”‚
          â”‚  - Queue clients              â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸŸ¨ Key Rules (Your Architecture Style)

### **1. API must not depend on infrastructure**
- API â†’ application  
- API âœ– infrastructure

### **2. Application must not depend on API or infrastructure**
- Application â†’ no frameworks  
- Application â†’ only ports + domain

### **3. Infrastructure depends on application**
- Infrastructure â†’ application  
- Infrastructure implements ports

### **4. All outbound ports start with `I`**
Examples:
- `ITemplateStorage`
- `IBatchQueueManager`
- `IUserRepository`

---

# ğŸŸª Example of the Relationship in Action

### API layer:
```
TemplateController â†’ TemplateService
```

### Application layer:
```
TemplateService â†’ ITemplateStorage
```

### Infrastructure layer:
```
S3TemplateStorage implements ITemplateStorage
```

---

# ğŸŸ« In One Sentence

**API calls application, application calls interfaces, infrastructure implements those interfaces.**

---
